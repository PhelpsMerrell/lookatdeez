import 'dart:convert';\nimport 'dart:html' as html;\nimport 'package:msal_js/msal_js.dart';\nimport 'package:jwt_decoder/jwt_decoder.dart';\nimport 'package:shared_preferences/shared_preferences.dart';\nimport '../config/auth_config.dart';\n\nclass AuthService {\n  static PublicClientApplication? _msalInstance;\n  static AuthenticationResult? _currentAuth;\n  \n  // Initialize MSAL\n  static Future<void> initialize() async {\n    try {\n      final config = Configuration(\n        auth: BrowserAuthOptions(\n          clientId: AuthConfig.clientId,\n          authority: AuthConfig.authority,\n          redirectUri: AuthConfig.currentRedirectUri,\n        ),\n        cache: CacheOptions(\n          cacheLocation: BrowserCacheLocation.localStorage,\n          storeAuthStateInCookie: false,\n        ),\n      );\n      \n      _msalInstance = await PublicClientApplication.createPublicClientApplication(config);\n      \n      // Handle redirect callback if we're returning from Microsoft login\n      await _handleRedirectPromise();\n    } catch (e) {\n      print('MSAL initialization error: $e');\n      rethrow;\n    }\n  }\n  \n  // Handle redirect after Microsoft login\n  static Future<void> _handleRedirectPromise() async {\n    try {\n      final response = await _msalInstance!.handleRedirectPromise();\n      if (response != null) {\n        _currentAuth = response;\n        await _saveUserInfo(response);\n      }\n    } catch (e) {\n      print('Redirect handling error: $e');\n    }\n  }\n  \n  // Login with Microsoft\n  static Future<AuthenticationResult?> login() async {\n    try {\n      final loginRequest = RedirectRequest(\n        scopes: AuthConfig.scopes,\n        redirectUri: AuthConfig.currentRedirectUri,\n      );\n      \n      // This will redirect to Microsoft login\n      await _msalInstance!.loginRedirect(loginRequest);\n      return null; // Will complete after redirect\n    } catch (e) {\n      print('Login error: $e');\n      rethrow;\n    }\n  }\n  \n  // Get access token (for API calls)\n  static Future<String?> getAccessToken() async {\n    try {\n      if (_currentAuth == null) {\n        // Try to get account from cache\n        final accounts = await _msalInstance!.getAllAccounts();\n        if (accounts.isEmpty) return null;\n        \n        final account = accounts.first;\n        final silentRequest = SilentRequest(\n          scopes: AuthConfig.scopes,\n          account: account,\n        );\n        \n        _currentAuth = await _msalInstance!.acquireTokenSilent(silentRequest);\n      }\n      \n      return _currentAuth?.accessToken;\n    } catch (e) {\n      print('Token acquisition error: $e');\n      // If silent acquisition fails, user needs to login again\n      return null;\n    }\n  }\n  \n  // Get user info from token\n  static Future<Map<String, dynamic>?> getUserInfo() async {\n    try {\n      final token = await getAccessToken();\n      if (token == null) return null;\n      \n      // Decode the JWT token to get user info\n      final decodedToken = JwtDecoder.decode(token);\n      \n      return {\n        'id': decodedToken['oid'] ?? decodedToken['sub'],\n        'email': decodedToken['email'] ?? decodedToken['preferred_username'],\n        'name': decodedToken['name'],\n        'given_name': decodedToken['given_name'],\n        'family_name': decodedToken['family_name'],\n      };\n    } catch (e) {\n      print('User info error: $e');\n      return null;\n    }\n  }\n  \n  // Save user info to local storage\n  static Future<void> _saveUserInfo(AuthenticationResult auth) async {\n    try {\n      final prefs = await SharedPreferences.getInstance();\n      \n      // Save the access token for API calls\n      await prefs.setString('access_token', auth.accessToken ?? '');\n      \n      // Decode and save user info\n      if (auth.idToken != null) {\n        final decodedToken = JwtDecoder.decode(auth.idToken!);\n        await prefs.setString('userId', decodedToken['oid'] ?? decodedToken['sub'] ?? '');\n        await prefs.setString('userEmail', decodedToken['email'] ?? decodedToken['preferred_username'] ?? '');\n        await prefs.setString('userName', decodedToken['name'] ?? '');\n      }\n    } catch (e) {\n      print('Save user info error: $e');\n    }\n  }\n  \n  // Check if user is logged in\n  static Future<bool> isLoggedIn() async {\n    try {\n      final accounts = await _msalInstance!.getAllAccounts();\n      return accounts.isNotEmpty;\n    } catch (e) {\n      return false;\n    }\n  }\n  \n  // Logout\n  static Future<void> logout() async {\n    try {\n      final accounts = await _msalInstance!.getAllAccounts();\n      if (accounts.isNotEmpty) {\n        final logoutRequest = EndSessionRequest(\n          account: accounts.first,\n          postLogoutRedirectUri: AuthConfig.currentRedirectUri,\n        );\n        await _msalInstance!.logoutRedirect(logoutRequest);\n      }\n      \n      // Clear local storage\n      final prefs = await SharedPreferences.getInstance();\n      await prefs.clear();\n      _currentAuth = null;\n    } catch (e) {\n      print('Logout error: $e');\n    }\n  }\n  \n  // Get stored user ID for API calls\n  static Future<String?> getUserId() async {\n    final prefs = await SharedPreferences.getInstance();\n    return prefs.getString('userId');\n  }\n  \n  // Get bearer token for API authorization\n  static Future<String?> getBearerToken() async {\n    final token = await getAccessToken();\n    return token != null ? 'Bearer $token' : null;\n  }\n}\n